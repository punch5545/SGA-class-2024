#include <stdio.h>

void MAX(int* value, int a, int b);
int SUM(int a, int b);
int SUB(int a, int b);

int main()
{
	int n = 100;
	double m = 3.14;

	int* nptr = &n;
	double* mptr = &m;

	int** npptr = &nptr;
	double** mpptr = &mptr;

	printf("int n \t\t\t= %d\n", n);
	printf("n 주소 \t\t\t: %#X\n", &n);
	printf("nptr \t\t\t= %#X\n", nptr);
	printf("nptr의 주소가 가진값 \t: %d\n", *nptr);
	printf("nptr의 주소 \t\t: %#X\n", &nptr);
	printf("npptr \t\t\t= %#X\n", npptr);
	printf("npptr의 주소가 가진값 \t: %#X\n", *npptr);
	printf("npptr의 주소가 가진가진값 \t: %d\n", **npptr);
	printf("npptr의 주소 \t\t: %#X\n", &npptr);

	printf("\n\n");

	printf("포인터의 크기 : %d\n", sizeof(nptr));
	/*
	* 포인터의 크기는 일반적으로 CPU에 따라 결정됨
	* 32비트 CPU에서는 1워드의 크기가 4바이트이므로 포인터의 변수 또한 4바이트
	* 
	* 워드?
	* CPU가 한번에 처리할 수 있는 데이터의 크기
	* 1byte = 8bit -> 32bit System : 32bit / 8bit = 4byte -> 4byte == 1word
	*				  64bit System : 64bit / 8bit = 8byte -> 8byte == 1word
	*/

	int a, b, value;
	a = 10;
	b = 20;
	value = 0;
	MAX(&value, 10, 20);

	printf("%d", value);
	
	int(*func)(int, int) = NULL;
	func = SUM;

	printf("%d", func(3, 5));
}

void MAX(int* value, int a, int b)
{
	if (a > b)
		*value = a;
	else if (b > a)
		*value = b;
	else
		*value = 0;
}

int SUM(int a, int b)
{
	return a + b;
}

int SUB(int a, int b)
{
	return a - b;
}

/*
* Pointer 주소값
*	- 해당 데이터가 저장된 메모리 시작 주소
*	- 이러한 주소값을 1바이트 크기의 메모리 공간으로 나누어서 표현
* 
*	int a;
* 
					메모리
 데이터의 주소값←	0X10[01110101] ┐
				0X11[11101010] │INT 4BYTE
				0X12[11111000] │
				0X13[00011010] ┘
 데이터의 주소값←	0X14[11010101] ] CHAR 1BYTE
				0X15[11111111]
				0X16[00000000]

* 포인터
*	- 메모리의 주소값을 저장하는 변수
*	- 포인터 변수라고 부름
* 
* ex) int  n = 100; -> 변수 선언
	  int* ptr = &n; -> 포인터 선언

					메모리
	변수 n←	┌→	0X10[01110101] ┐
			│	0X11[11101010] │100
			│	0X12[11111000] │
			│	0X13[00011010] ┘
			│	0X14[11010101]
			│	0X15[11111111]
			│	0X16[00000000]
			│	0X17[00000000]
			│	0X18[00000000]
			│	0X19[00000000]
			│		  .
			│		  .
			│		  .
  포인터ptr←	└─	0X5E[00000000] ┐
				0X5F[00000000] │0x10
				0X60[00000000] │
				0X61[00000000] ┘

* 포인터 연산자
*	1) 주소 연산자 (&)
*		- 변수 이름 앞에 사용
*		- 해당 변수의 주소값을 반환
*		- 앰퍼샌드라고 읽으며, 번지 연산자라고도 불림
*	2) 참조 연산자 (*)
*		- 포인터의 이름이나 주소 앞에 사용
*		- 포인터의 가리키는 주소에 저장된 값을 반환
* 
* 
					메모리
	변수 n←	┌→	0X10[01110101] ┐
			│	0X11[11101010] │100
			│	0X12[11111000] │
			│	0X13[00011010] ┘
			│	0X14[11010101]
			│		  .
			│		  .
			│		  .
			│	0X5D[00000000]
  포인터ptr←	└─	0X5E[00000000]←	┐	┐
				0X5F[00000000]	│	│0x10
				0X60[00000000]	│	│
				0X61[00000000]	│	┘
					  .			│
					  .			│
					  .			│
				0X6F[00000000]	│
  포인터pptr  ←	0X70[00000000]─	┘	┐
				0X71[00000000]		│0x5E
				0X72[00000000]		│
				0X73[00000000]		┘

* 포인터의 연산
*	- 포인터는 값을 증가시키거나 감소시크는 등 제한된 연산만 가능
*	- 규칙
*		1) 포인터끼리의 덧셈, 곱셈, 나눗셈은 아무런 의미가 없음
*		2) 포인터끼리의 뺄셈은 두 포인터 사이의 상대적인 거리다
*		3) 포인터에 정수를 더하거나 뺄 수 있지만, 실수와의 연산은 허용되지 않는다
*		4) 포인터끼리 대입하거나 비교할 수 없다
*/

/*
	초기 주소값 : 0
	1을 증가시키는 포인터 연산 후 포인터가 가리키고 있는 주소는 각각의 포인터 타입에 따라 달라진다.
	증가폭 = 포인터가 가리키는 변수의 타입 크기

	(int)	0X10[01110101]┐
			0X11[11101010]│ptr
			0X12[11111000]│
			0X13[00011010]┘
			0X14[11010101]┐
			0X15[11111111]│ptr + 1
			0X16[00000000]│
			0X14[11010101]┘
			0X15[11111111]┐
			0X16[00000000]│ptr + 2
			0X14[11010101]│
			0X15[11111111]┘

	(char)	0x10[01110101]] ptr
			0X11[11101010]] ptr + 1
			0X12[11111000]] ptr + 2
			0X13[00011010]] ptr + 3
*/

/*
* 특이한 포인터
* 1. void 포인터
*	- 일반적인 포인터 변수와 다르게 대상이 되는 데이터의 타입을 명시하지 않은 포인터
*	- 변수, 함수, 포인터 등 어떠한 값도 가르킬 수 있다
*	- 포인터 연산이나 메모리 참조와 같은 작업은 할 수 없다
*	- void 포인터는 사용할 때마다 명시적 형변환을 하고 난 뒤에 사용할 수 있다
* 
* 2. 함수 포인터
*	- 프로그램에서 정의된 함수는 모두 프로그램이 실행될 때 메인 메모리에 올라감
*	- 이때 함수의 이름은 메모리의 올라간 함수의 시작 주소를 가리키는 포인터 상수가 됨
*	- 함수의 시작 주소를 가리키는 포인터 상수를 함수 포인터라고 부름
*/
