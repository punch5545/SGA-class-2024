# 2024-01-08 (Mon) : CPP

## CLASS - Function

### 함수 호출 과정
1. 스택에 함수로 전달할 매개변수와 함께 끝난 뒤 돌아갈 반환 주소값을 저장
2. 프로그램의 제어가 함수의 위치로 넘어와 함수 내에 선언된 지역 변수도 스택에 저장
3. 함수의 모든 코드를 실행
4. 실행이 전부 끝나고 반환값을 넘김
5. 프로그램의 제어는 스택에 저장된 돌아갈 반환 주소값으로 이동
6. 스택에 저장된 함수 호출 정보를 제거

### 함수의 오버로딩 (OverLoad)
- 같은 이름의 함수 정의 가능
- 인자의 자료형, 인자 개수가 달라야 함
- 예제
    ```cpp
    int Sum(int a, int b);
    float Sum(float a, float b);
    ```

### 함수 시그니처
- 함수의 원형에 명시되는 매개변수 리스트
- 두 함수의 매개변수의 개수와 타입이 같다면, 두 함수의 시그니처는 같다고 할 수 있다

### 함수의 기본 인자
- 매개변수를 전달하지 않으면 기본값으로 초기화되는 인자
- 기본값이 할당된 인자가 정의된 인자 뒤에 일반 인자를 정의할 수 없음
- 규칙
    1) 함수의 원형에서만 지정 가능
    2) 가장 오른쪽부터 시작하여 순서대로 지정 가능
    3) 가운데 인수만 별도로 지정 불가

- 예제
    ```cpp
    int Print(int age = 0, string name); // (X)

    int Print(string name, int age = 0); // (O)

    Print("홍길동", 20);
    Print("홍길동"); // age = 0으로 초기화
    ```

### 참조자
- 실제 이름 대신 사용할 수 있는 새로운 기능
- 크기가 큰 구조체와 같은 데이터를 함수의 인수로 전달해야 할 경우 사용 가능
- 클래스를 설계할 때에도 자주 사용함
- 참조자는 대상 변수와 같은 메모리 위치를 참조함
- 주의사항
    1. 참조자의 타입은 대상이 되는 변수의 타입과 동일해야 함
    2. 선언과 동시에 초기화 해야 함
    3. 한번 초기화되면 대상 변경이 불가능함.
- 함수의 인수로서 전달이 가능함
    - 함수가 참조자를 인수로 전달받으면, 참조하고 있는 변수값을 함수 내에서 조작이 가능함
    - `Call by Address`와 작동방식이 동일함 
    - 예제
        ```cpp
        int a = 0, b = 1;
        int Sum(int& a, int& b)
        {
            a += 1;
            b += 2;
            return a + b;
        }

        cout >> Sum(a,b) >> endl;
        // 출력: 3 ((0 + 1) + (1 + 2))
        
        ```
    - struct, class의 경우 포인터 지정 연산자 `->`가 아닌 `.`으로 멤버에 접근
- 참조자에 의한 전달의 특징
    - 함수 내에서 참조연산자`*`를 사용하지 않으므로 함수 내부의 코드가 깔끔하고 직관적임
    - 값에 의한 전달 방법과 같은 형태가 되어 코드를 구분하기 쉽지 않음
    - 참조 호출이 꼭 필요할 때에는 참조자보다는 포인터를 사용하는 것이 직관적임.

### Constant: 상수
- `const` 키워드를 자료형 앞에 사용
- `const` 선언이 된 변수의 경우 변수 값을 읽기만 가능, 쓰기 불가

### Inline
- 함수 호출지점에 함수의 내용을 치환해 함수 호출에 소요되는 시간을 줄여줌
- 함수 선언 앞에 `inline` 키워드 사용

### Macro
- `#define`으로 정의
- 런타임이 아닌 컴파일타임에 정의됨
- 치환의 역할만 해주므로, 연산 시 연산 우선순위 고려 필요
- Inline 함수와의 차이
    - `inline`은 단순 치환이 아닌 함수의 모든 코드를 호출된 자리에 인라인 코드로 삽입
    - 일반 함수처럼 값이나 수식을 인수로 전달할 수 있음
    - 매개변수 타입에 맞춘 자동 형변환도 지원함.

## lvalue - rvalue
- lvalue: 주소값을 취할 수 있는 값
- rvalue: 주소값을 취할 수 없는 값

- `&` : lvalue 참조 연산자
- `&&` : rvalue 참조 연산자


### Constructor: 생성자
- 객체의 생성과 동시에 멤버 변수를 초기화해주는 멤버 함수
- 클래스 생성자의 이름은 해당 클래스의 이름과 같음
- 종류
    - 기본 생성자
    - 매개변수가 있는 생성자
    - 복사 생성자
    - 이동 생성자
- 특징
    1. 초기화를 위한 데이터를 인수로 전달받을 수 있음
    2. 반환값이 없지만 void선언을 하지 않음
    3. 객체를 초기화하는 방법이 여러개 존재할 경우에는 오버로딩 규칙에 따라 여러 개의 생성자를 가질 수 있음.

### 얕은 복사, 깊은 복사
#### 얕은 복사
- 값을 복사하는 것이 아닌 값을 가리키는 포인터를 복사
- 변수 생성에서 대입 연산자를 이용한 값의 복사는 문제가 없지만, 객체에서는 문제가 발생할 수 있음.
- 객체의 멤버가 메모리 Heap 영역을 참조할 경우 문제 발생
#### 깊은 복사
- 복사 생성자를 재정의함으로써 원하는 멤버 변수만 복사

### 소멸자
- 객체가 소멸될 때 자동으로 실행되는 클래스의 멤버 함수
- 생성자 -> 클래스의 초기화 / 소멸자 -> 청소
- 호출되는 경우
    1. 지역에서 생성된 객체가 지역 범위를 벗어남
    2. 동적으로 할당된 객체가 삭제 키워드를 사용해 명시적으로 삭제
- 객체가 메모리에서 제거되기 전에 필요한 정리를 수행
- 소멸자가 있는 경우 자동으로 호출됨
- 클래스가 소멸하기 전에 동적 메모리, 파일 또는 DB핸들러 등의 다른 리소스를 해제
- 규칙
    1. 클래스와 이름이 같으며, ~를 붙임 `예: ~SomeClass();`
    2. 인수, 반환값 없음
    3. 오버로딩 불가(하나만 존재)
    4. 명시적 호출 불가

### 연산자 오버로딩
- 기존 함수 오버로딩의 개념을 연산자까지 확대
- 하나의 연산자를 여러 의미로 사용할 수 있게 해줌
- 연산자 오버로딩을 사용하여 정의 타입까지 확장 가능
- 클래스도 하나의 타입임을 확실하게 보여줌

#### `operator` 연산자 함수
- 연산자를 오버로딩하기 위해 사용
- 문법
    - operator연산자(매개변수목록)
    - 예: `operator=(T& other)`
    오버로딩할 연산자는 적법한 C++ 연산자여야 함
    - `operator` 키워드와 공백 없이 연결되어야 한다.


### 멤버 함수의 공유
- 클래스에서 생성된 인스턴스는 각각 독립된 메모리 공간에 저장된 자신만의 멤버 변수를 가짐
- 멤버 함수는 모든 인스턴스가 공유함. (함수는 하나만 생성)

### this
- 멤버함수의 공유 등과 같은 문제로 모든 멤버 함수가 자신만의 `this` 포인터를 가지고 있음.
- 해당 멤버 함수를 호출한 객체를 가리킴
- 호출된 멤버 함수는 자신을 호출한 객체가 무엇인지 정확하게 파악
- 특징
    1. 클래스, 구조체 또는 열거체 타입의 비정적 멤버 함수에서만 사용 가능
    2. 정적 멤버 함수는 `this` 포인터를 가지지 않음
    3. `this` 포인터는 언제나 포인터 상소, 값을 재할당 할 수 없다.